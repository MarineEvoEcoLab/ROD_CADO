---
title: "ROD CADO Outlier Detection"
output:
  html_notebook:
    fig_caption: yes
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document:
    toc: yes
    toc_depth: '3'
  html_document:
    keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# LFMM2

Following steps documented by pgugger [here](https://github.com/pgugger/LandscapeGenomics/blob/master/2019/Exercise3.md) to prep the genomic and environmental data.

### loading the required libraries

```{r}
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")

BiocManager::install("LEA")
```

```{r}
library(LEA)
```
 
For LFMM, the input genomic data needs to be SNPs as genotypes encoded 0, 1, or 2 for the number of non-reference alleles. Missing data is coded as "-1" with vcftools and we will code them as. "9".

In terminal:

First linked the VCF file to the same directory as the saved script. 

```{bash}
ln -s /home/Shared_Data/ROD_CADO/analysis/raw.vcf/filtered/SNP.TRSdp10g1.FIL.vcf.gz .
```

```{bash}
# Converting vcf to genotyped file for input
vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --012 --out snp_rod

# Replacing missing data with 9 and creating the .lfmm file
sed 's/-1/9/g' snp_rod.012 | cut -f2- > snp_rod.lfmm
```

Checking for missing data. We shouldn't have any because any missing data was removed during filtering. If we did have missing data, we would need to complete another step to have the missing data coded as imputed data and not 9 since LFMM required a complete data frame, meaning no missing genetic data.

```{bash}
grep -o 9 snp_rod.lfmm | wc -l
```

Now running structure analysis: 

```{r,echo=TRUE, results='hide',message=FALSE,warning=FALSE}
# run snmf to estimate K, considering K from 1-10:
project_rod = NULL
project_rod = snmf("snp_rod.lfmm", K = 1:10, entropy = TRUE, repetitions = 10, project = "new")
#pdf("sNMF_rod.pdf")
plot(project_rod, col = "blue", pch = 19, cex = 1.2)
#dev.off()
```

Based on the plot of cross-entropy, K = 5 or K = 7 has the lowest cross-entropy value. After talking to Jon,  it was suggested to interpret this plot more like a scree plot. In that case, we would choose K = 4 which also corresponds to the number of treatments. We interpret this like a scree plot, so we look for where the elbow of the plot is. 

Determining K is a key step for LFMM. LFMM accounts for the background associations seen in genetic vatiation with environmental variation using latent factors to model the unobserved variation/background structure. We must determine the amount of latent factors to include, and this in turn influences the power of the test. It is recommended to first start by using the number of population clusters, K from the structure analysis as the initial value, the consider Ks slightly higher or lower to control power and error. snmf is a function in LEA that estimates K. 

The plot we see from the above step has entropy on the y-axis. We want to see what value of k has the lowest entropy. This shows how well K explains the variance. A lower K value has better prediction capability and there is less conflict in the model.

```{r}
# Generating a Structure-type plot. 
best_rod = which.min(cross.entropy(project_rod, K = 4))

# pdf("sNMF.barchart_rod.pdf")
barchart(project_rod, K = 4, run = best_rod, border = NA, space = 0, col = c("red", "blue","green","yellow"), xlab = "Individuals", ylab = "Ancestry proportions") -> bp_rod
axis(1, at = 1:length(bp_rod$order), labels = bp_rod$order, las=1, cex.axis = .3)
#dev.off()
```

   
## Prepping environmental data

We are making a strata file with the treatment information for each sample. In a text editor, we made a dataframe with 5 columns: Individual, Population (Treatment Replicate), CADO, Disease, and the combination of CADO and disease. Individual was each sample name. Population was the corresponding treatment replicate. CADO was a binary classification: 0 for no Stress, 1 for Stress. Disease was a binary classification: 0 for no disease challenge, 1 for disease challenge. We then added the dataframe as a .txt file using `nano`:

```{bash}
nano strata_ROD
```

The colummns need to be tab delimited. We ensured this with the following line: 

```{bash}
sed 's/ \+/\t/g' strata_ROD > strata_ROD_tab
```

The final strata file is located [here](https://github.com/MarineEvoEcoLab/ROD_CADO/blob/main/Outlier_detection/strata_ROD_tab).

```{r}
# Prepping a second env file for downstream processing of LFMM output
clim.env_rod <- read.table("./strata_ROD_tab", header=TRUE)
```

### LFMM ridge

I am following steps documented by B.R. Forester [here](https://bookdown.org/hhwagner1/LandGenCourse_book/WE_11.html) for running the LFMM ridge model.

```{r}
# if(!requireNamespace("qvalue", quietly = TRUE)) {  
# if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
# BiocManager::install(version = "3.14")
# BiocManager::install("qvalue")
# }
# if(!requireNamespace("lfmm", quietly = TRUE)) {  
#  remotes::install_github("bcm-uga/lfmm")
# }
```

loading in packages: 

```{r}
library(vegan)    
library(lfmm)     # Used to run LFMM
library(qvalue)   # Used to post-process LFMM output
library(vcfR)
```

### Import the genetic data

```{r}
gen_rod<-read.delim("snp_rod.lfmm",header = FALSE)
```
Setting the dimensions of the matrix below. The rows ar ethe individuals and the columns are the number of SNPs overall. 
```{r}
row.names(gen_rod) <- clim.env_rod$Individual # Adding individual names to rows of matrix
dim(gen_rod)
```
Then, we save each environmental variable as a single variable for use in LFMM. 
```{r}
# Save each predictor as its own variable
CADO <- clim.env_rod$CADO

DIS <- clim.env_rod$Disease

COMB_BIN <- clim.env_rod$Combined_Bin

COMB_ADD <- clim.env_rod$Combined_Add
```

## Determine K (estimate of number of populations in the data)

```{r}
gen_rod.pca <- rda(gen_rod, scale=T)
screeplot(gen_rod.pca, main = "Screeplot of Genetic Data with Broken Stick", bstick=TRUE, type="barplot")
```

For the genomic data, we can see that one of the PCs have eigenvalues greater than random (greater than the broken stick values in red). This effectively means that K=2 for the genomic data set, based on a PCA assessment. This is because K = 2 is the value where the red “broken stick” is not contained in the values. I'm going to move forward, trying both K = 2 (from broken stick method) and K = 4 (from STRUCTURE analysis). We'll see how the output changes for both.

### Run LFMM 
First, we ran LFMM on the stress variable. 
Looking at the CADO variable first. We looked at CADO and disease separately, so we will run through this twice. The ridge step takes a little while to run. 

Below, where we set K to 4, this is so we can reference it later. 
```{r}
oys_rod_CADO.lfmm <- lfmm_ridge(Y=gen_rod, X=CADO, K=4) ## change K as you see fit
```

```{r}
#calculating test statistics for the predictor
oys_rod_CADO.pv <- lfmm_test(Y=gen_rod, X=CADO, lfmm=oys_rod_CADO.lfmm, calibrate="gif")

names(oys_rod_CADO.pv) # this object includes raw z-scores and p-values, as well as GIF-calibrated scores and p-values
```

Next, we calculate test statistics from the model. We are especially interested in the genomic inflation factor (GIF). 

```{r}
#Looking at the genomic inflation factor (GIF) - a value around 1 means the test(s) is appropriately calibrated. Here it is 1.08.
oys_rod_CADO.pv$gif
```

An appropriately calibrated set of tests will have a GIF of around 1. An elevated GIF would indicate that the results may be overly liberal in identifying candidate SNPs. If the GIF is less than one, the test may be too conservative. The GIF relates to how the model accounts for different factors. It affects how p-values are calculated for each SNP to determine significance. Below, we will look at the histograms of the p-values.  

```{r}
# look at how application of the GIF to the p-values impacts the p-value distribution:
hist(oys_rod_CADO.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_CADO.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values")
```

There should be a relatively flat histogram (most loci not under selection) with a peak near zero, indicative of candidate adaptive markers. If you have a big peak around 0, it indicates a lot of outliers. You may not have outliers with the default GIF value but you can readjust this GIF value and reassess. Decreasing the GIF value may help. You can then run PCA on the outliers to see if the stress outliers are different from the control outliers to confirm your findings. 

```{r}
# Let's change the GIF and readjust the p-values:
zscore_rod_CADO <- oys_rod_CADO.pv$score[,1]   # zscores for first predictor, we only have one in our case...
(gif_rod_CADO <- oys_rod_CADO.pv$gif[1])       ## d.fault GIF for this predictor
```

```{r}
new.gif <- 0.98           ## choose your new GIF

# Manual adjustment of the p-values:
adj.pv_rod_CADO <- pchisq(zscore_rod_CADO^2/new.gif, df=1, lower = FALSE)
```
Below, we calculate the new p-values based on the adjusted GIF. We decided to go with a GIF of 0.98. 
```{r}
# plot the p-value histograms with the new gif
hist(oys_rod_CADO.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_CADO.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values (GIF=1.08)")
hist(adj.pv_rod_CADO, main="REadjusted p-values (GIF=0.98)")
```

An FDR of 10% is usually standard to identify outliers. The FDR threshold can be used to adjust for false positives. q-values represent each SNP’s significance, taking into account the fact that thousands of SNPs are being tested. The steps below establish an FDR threshold. 

```{r}
#convert adjusted p-values to q values - q-values provide a measure of each SNP’s significance, automatically taking into account the fact that thousands are simultaneously being tested
# then an FDR threshold can be used to control the number of false positive detections
oys_rod_CADO.qv <- qvalue(oys_rod_CADO.pv$calibrated.pvalue)$qvalues
length(which(oys_rod_CADO.qv < 0.1)) ## how many SNPs have an FDR < 10%?
```

```{r}
#Trying with the GIF adjusted value
oys_rod_CADO.qv <- qvalue(adj.pv_rod_CADO)$qvalues
length(which(oys_rod_CADO.qv < 0.1)) ## how many SNPs have an FDR < 10%?
```

```{r}
oys_rod_CADO.FDR.1 <- as.vector(which(oys_rod_CADO.qv < 0.1)) ## identify which SNPs these are
oys_rod_CADO.FDR.1
```

```{r}
invisible(lapply(oys_rod_CADO.FDR.1, write, "outliers_lfmm2_CADO_098.txt", append=TRUE))
```


**Now looking at the disease variable.**

Now looking at the disease variable.This is repeating everything that we did above, except now examining disease. 

```{r}
oys_rod_DIS.lfmm <- lfmm_ridge(Y=gen_rod, X=DIS, K=4) ## change K as you see fit
```

```{r}
#calculating test statistics for the predictor
oys_rod_DIS.pv <- lfmm_test(Y=gen_rod, X=DIS, lfmm=oys_rod_DIS.lfmm, calibrate="gif")

names(oys_rod_DIS.pv) # this object includes raw z-scores and p-values, as well as GIF-calibrated scores and p-values
```

```{r}
#Looking at the genomic inflation factor (GIF) - a value around 1 means the test(s) is appropriately calibrated. Here it is 1.27.
oys_rod_DIS.pv$gif
```

An appropriately calibrated set of tests will have a GIF of around 1. An elevated GIF would indicate that the results may be overly liberal in identifying candidate SNPs. If the GIF is less than one, the test may be too conservative.

```{r}
# look at how application of the GIF to the p-values impacts the p-value distribution:
hist(oys_rod_DIS.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_DIS.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values")
```

There should be a relatively flat histogram (most loci not under selection) with a peak near zero, indicative of candidate adaptive markers.

```{r}
# Let's change the GIF and readjust the p-values:
zscore_rod_DIS <- oys_rod_DIS.pv$score[,1]   # zscores for first predictor, we only have one in our case...
(gif_rod_DIS <- oys_rod_DIS.pv$gif[1])       ## d.fault GIF for this predictor
```

```{r}
new.gif <- 0.98           ## choose your new GIF

# Manual adjustment of the p-values:
adj.pv_rod_DIS <- pchisq(zscore_rod_DIS^2/new.gif, df=1, lower = FALSE)
```

```{r}
# plot the p-value histograms with the new gif
hist(oys_rod_DIS.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_DIS.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values (GIF=1.27)")
hist(adj.pv_rod_DIS, main="REadjusted p-values (GIF=0.98)")
```

```{r}
#convert adjusted p-values to q values - q-values provide a measure of each SNP’s significance, automatically taking into account the fact that thousands are simultaneously being tested
# then an FDR threshold can be used to control the number of false positive detections
oys_rod_DIS.qv <- qvalue(oys_rod_DIS.pv$calibrated.pvalue)$qvalues
length(which(oys_rod_DIS.qv < 0.1)) ## how many SNPs have an FDR < 10%?
```

```{r}
#Trying with the GIF adjusted value
oys_rod_DIS.qv <- qvalue(adj.pv_rod_DIS)$qvalues
length(which(oys_rod_DIS.qv < 0.1)) ## how many SNPs have an FDR < 10%?
```

```{r}
oys_rod_DIS.FDR.1 <- as.vector(which(oys_rod_DIS.qv < 0.1)) ## identify which SNPs these are
oys_rod_DIS.FDR.1
```

```{r}
invisible(lapply(oys_rod_DIS.FDR.1, write, "outliers_lfmm2_DIS_087.txt", append=TRUE))
```

**Now looking at the combined variable (binary).**

```{r}
oys_rod_CB.lfmm <- lfmm_ridge(Y=gen_rod, X=COMB_BIN, K=4) ## change K as you see fit
```

```{r}
#calculating test statistics for the predictor
oys_rod_CB.pv <- lfmm_test(Y=gen_rod, X=COMB_BIN, lfmm=oys_rod_CB.lfmm, calibrate="gif")

names(oys_rod_CB.pv) # this object includes raw z-scores and p-values, as well as GIF-calibrated scores and p-values
```

```{r}
#Looking at the genomic inflation factor (GIF) - a value around 1 means the test(s) is appropriately calibrated. Here it is 1.41.
oys_rod_CB.pv$gif
```

An appropriately calibrated set of tests will have a GIF of around 1. An elevated GIF would indicate that the results may be overly liberal in identifying candidate SNPs. If the GIF is less than one, the test may be too conservative.

```{r}
# look at how application of the GIF to the p-values impacts the p-value distribution:
hist(oys_rod_CB.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_CB.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values")
```

There should be a relatively flat histogram (most loci not under selection) with a peak near zero, indicative of candidate adaptive markers.

```{r}
# Let's change the GIF and readjust the p-values:
zscore_rod_CB <- oys_rod_CB.pv$score[,1]   # zscores for first predictor, we only have one in our case...
(gif_rod_CB <- oys_rod_CB.pv$gif[1])       ## d.fault GIF for this predictor
```
The original GIF had 107 outliers. We ended up going with this GIF, but below we try another GIF to confirm this. 
```{r}
new.gif <- 1.00           ## choose your new GIF

# Manual adjustment of the p-values:
adj.pv_rod_CB <- pchisq(zscore_rod_CB^2/new.gif, df=1, lower = FALSE)
```

```{r}
# plot the p-value histograms with the new gif
hist(oys_rod_CB.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_CB.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values (GIF=1.41)")
hist(adj.pv_rod_CB, main="REadjusted p-values (GIF=1.00)")
```

```{r}
#convert adjusted p-values to q values - q-values provide a measure of each SNP’s significance, automatically taking into account the fact that thousands are simultaneously being tested
# then an FDR threshold can be used to control the number of false positive detections
oys_rod_CB.qv <- qvalue(oys_rod_CB.pv$calibrated.pvalue)$qvalues
length(which(oys_rod_CB.qv < 0.1)) ## how many SNPs have an FDR < 10%?
```

```{r}
oys_rod_CB.FDR.1 <- which(oys_rod_CB.qv < 0.1) ## identify which SNPs these are
oys_rod_CB.FDR.1
```

```{r}
invisible(lapply(oys_rod_CB.FDR.1, write, "outliers_lfmm2_CB.txt", append=TRUE))
```


**Now looking at the combined variable (additive).**

```{r}
oys_rod_ADD.lfmm <- lfmm_ridge(Y=gen_rod, X=COMB_ADD, K=4) ## change K as you see fit
```

```{r}
#calculating test statistics for the predictor
oys_rod_ADD.pv <- lfmm_test(Y=gen_rod, X=COMB_ADD, lfmm=oys_rod_ADD.lfmm, calibrate="gif")

names(oys_rod_ADD.pv) # this object includes raw z-scores and p-values, as well as GIF-calibrated scores and p-values
```

```{r}
#Looking at the genomic inflation factor (GIF) - a value around 1 means the test(s) is appropriately calibrated. Here it is 1.29.
oys_rod_ADD.pv$gif
```

An appropriately calibrated set of tests will have a GIF of around 1. An elevated GIF would indicate that the results may be overly liberal in identifying candidate SNPs. If the GIF is less than one, the test may be too conservative.

```{r}
# look at how application of the GIF to the p-values impacts the p-value distribution:
hist(oys_rod_ADD.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_ADD.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values")
```

There should be a relatively flat histogram (most loci not under selection) with a peak near zero, indicative of candidate adaptive markers.

```{r}
# Let's change the GIF and readjust the p-values:
zscore_rod_ADD <- oys_rod_ADD.pv$score[,1]   # zscores for first predictor, we only have one in our case...
(gif_rod_ADD <- oys_rod_ADD.pv$gif[1])       ## d.fault GIF for this predictor
```

```{r}
new.gif <- 1.00           ## choose your new GIF

# Manual adjustment of the p-values:
adj.pv_rod_ADD <- pchisq(zscore_rod_ADD^2/new.gif, df=1, lower = FALSE)
```

```{r}
# plot the p-value histograms with the new gif
hist(oys_rod_ADD.pv$pvalue[,1], main="Unadjusted p-values")        
hist(oys_rod_ADD.pv$calibrated.pvalue[,1], main="GIF-adjusted p-values (GIF=1.29)")
hist(adj.pv_rod_ADD, main="REadjusted p-values (GIF=1.00)")
```

```{r}
#convert adjusted p-values to q values - q-values provide a measure of each SNP’s significance, automatically taking into account the fact that thousands are simultaneously being tested
# then an FDR threshold can be used to control the number of false positive detections
oys_rod_ADD.qv <- qvalue(oys_rod_ADD.pv$calibrated.pvalue)$qvalues
length(which(oys_rod_ADD.qv < 0.1)) ## how many SNPs have an FDR < 10%?
```

```{r}
oys_rod_ADD.FDR.1 <- which(oys_rod_ADD.qv < 0.1) ## identify which SNPs these are
oys_rod_ADD.FDR.1
```

```{r}
invisible(lapply(oys_rod_ADD.FDR.1, write, "outliers_lfmm2_C_ADD.txt", append=TRUE))
```

These 12 were also identified for the combined_binary variable. The combined_binary had 95 additional outliers. We will move forward with the combined binary variable outliers, but I will keep track of these specific 12 as outliers of interest. 

### Modified GIF Exploratory Analysis 

With the CADO and Disease variables, outlier loci were only identified when the GIF was modified from the calculated value. As there is no documentation on how to choose a modified GIF value, I will perform exploratory analysis, examining outlier SNPs detected using different GIF values for each variable. For each variable, I'm testing 4 different GIF values. The four values were chosen based on how many outliers were identified. Basically, I was trying to find the point where there was a huge increase in the number of outliers detected and then chose values right before and after that point. 

For CADO, I tested the following GIF values and report the number of outliers detected for each. Bold values indicate the ones I chose to explore further:

|      GIF     | # of outliers |
|--------------|---------------|
| 1.08 (calc.) |      0        |
|    1.00      |      1        |
|  **0.98**    |    **5**      |
|  **0.96**    |    **31**     |
|  **0.95**    |    **45**     |
|  **0.94**    |    **140**    |
|  **0.90**    |    **304**    |


For Disease, I tested the following GIF values and report the number of outliers detected for each. Bold values indicate the ones I chose to explore further:

|      GIF     | # of outliers |
|--------------|---------------|
| 1.27 (calc.) |      0        |
|    1.00      |      0        |
|    0.99      |      3        |
|  **0.98**    |    **3**      |
|  **0.97**    |    **26**     |
|  **0.96**    |    **29**     |
|  **0.93**    |    **47**     |
|  **0.92**    |    **181**    |
|  **0.90**    |    **667**    |

Fist, create a file that includes the chromosome and position for each SNP index.

```{bash loci.plus.index file}
zcat SNP.TRSdp10g1.FIL.vcf.gz | mawk '!/#/' | cut -f1,2 > totalloci
NUM=(`cat totalloci | wc -l`)
paste <(seq 1 $NUM) totalloci > loci.plus.index
```

Now update the outlier SNP index txt files to add the chromosome and position for each SNP. I'll do this for each test file.

```{bash outlier loci position files}
# CADO outlier files
cat outliers_lfmm2_CADO_098.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_CADO_098.loci.txt

cat outliers_lfmm2_CADO_096.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_CADO_096.loci.txt

cat outliers_lfmm2_CADO_095.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_CADO_095.loci.txt

cat outliers_lfmm2_CADO_094.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_CADO_094.loci.txt

cat outliers_lfmm2_CADO_09.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_CADO_09.loci.txt

# Disease outlier files
cat outliers_lfmm2_DIS_098.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_098.loci.txt

cat outliers_lfmm2_DIS_097.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_097.loci.txt

cat outliers_lfmm2_DIS_096.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_096.loci.txt

cat outliers_lfmm2_DIS_093.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_093.loci.txt

cat outliers_lfmm2_DIS_092.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_092.loci.txt

cat outliers_lfmm2_DIS_09.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_09.loci.txt

cat outliers_lfmm2_DIS_087.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_DIS_087.loci.txt

# Combined treatment outliers
cat outliers_lfmm2_CB.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_CB.loci.txt

cat outliers_lfmm2_C_ADD.txt | parallel "grep -w ^{} loci.plus.index" | cut -f2,3 > outliers_lfmm2_C_ADD.loci.txt
```

Using vcftools, create VCF files with just the outlier SNPs.

```{bash}
# CADO
vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_CADO_098.loci.txt --out outliers_lfmm2_CADO_098

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_CADO_096.loci.txt --out outliers_lfmm2_CADO_096

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_CADO_095.loci.txt --out outliers_lfmm2_CADO_095

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_CADO_094.loci.txt --out outliers_lfmm2_CADO_094

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_CADO_09.loci.txt --out outliers_lfmm2_CADO_09

# Disease
vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_098.loci.txt --out outliers_lfmm2_DIS_098

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_097.loci.txt --out outliers_lfmm2_DIS_097

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_096.loci.txt --out outliers_lfmm2_DIS_096

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_093.loci.txt --out outliers_lfmm2_DIS_093

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_092.loci.txt --out outliers_lfmm2_DIS_092

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_09.loci.txt --out outliers_lfmm2_DIS_09

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_DIS_087.loci.txt --out outliers_lfmm2_DIS_087

# Combined treatment outliers
vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_CB.loci.txt --out outliers_lfmm2_CB

vcftools --gzvcf SNP.TRSdp10g1.FIL.vcf.gz --recode --recode-INFO-all --positions outliers_lfmm2_C_ADD.loci.txt --out outliers_lfmm2_C_ADD
```


For each VCF file, I'm going to run PCA and a PERMANOVA to test for significant differences between treatments. My thought is that is there is a significant difference with even the larger outlier SNP datasets, then we can say they are outliers with more confidence. 

```{r}
library(vcfR)
library(tibble)
library(ggplot2)
```

```{r}
# Setting up strata file - population info and environmental data 
strata_ROD <- read.table("./strata_ROD_tab", header=TRUE)
```

```{r}
pop <- c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20))
```

```{r}
Stress <- c(rep("No", 20),rep("Yes", 20),rep("No", 20),rep("Yes", 20))

Disease <- c(rep("No", 20),rep("No", 20),rep("Yes", 20),rep("Yes", 20))
```
Below, we try different GIF values for the different treatments. 
# CADO variable 0.98 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_CADO_098 <- read.vcfR("outliers_lfmm2_CADO_098.recode.vcf")
```

```{r}
rad_out_lfmm_CADO_098.filt <- vcfR2genind(vcf_out_lfmm_CADO_098, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_CADO_098.filt
```
Below, we plot a PCA. 
```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_CADO_098 <- scaleGen(rad_out_lfmm_CADO_098.filt, NA.method = "mean")
out_lfmm_CADO_098_pca <- dudi.pca(x_out_lfmm_CADO_098, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_CADO_098 <- round((out_lfmm_CADO_098_pca$eig / (sum(out_lfmm_CADO_098_pca$eig))) * 100, 2)

pca_dat_out_lfmm_CADO_098 <- as.data.frame(out_lfmm_CADO_098_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_CADO_098.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_CADO_098 <- pca_dat_out_lfmm_CADO_098 %>%
  mutate(Stress = ifelse(pop %in% c("CH", "RH"), "Yes", "No"))
```

```{r}
pc_scores_CADO_098 <- out_lfmm_CADO_098_pca$li
```

```{r}
permanova_result_CADO_098 <- adonis2(pc_scores_CADO_098 ~ pop, method = "euclidean")
print(permanova_result_CADO_098)
```

```{r}
permanova_result_CADO_098 <- adonis2(pc_scores_CADO_098 ~ Stress, method = "euclidean")
print(permanova_result_CADO_098)
```

```{r}
pca_data_CADO_098 <- data.frame(PC1 = pc_scores_CADO_098[,1], PC2 = pc_scores_CADO_098[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CADO_098 <- permanova_result_CADO_098$`Pr(>F)`[1]

eigenvalues_CADO_098 <- eigen(cov(pca_data_CADO_098[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_098 <- eigenvalues_CADO_098 / sum(eigenvalues_CADO_098) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_098, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_098[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_098[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_098, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_CADO_098 <- data.frame(PC1 = pc_scores_CADO_098[,1], PC2 = pc_scores_CADO_098[,2], Treatment = Stress)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Stress")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_CADO_098 <- permanova_result_CADO_098$`Pr(>F)`[1]

eigenvalues_CADO_098 <- eigen(cov(pca_data_CADO_098[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_098 <- eigenvalues_CADO_098 / sum(eigenvalues_CADO_098) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_098, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_098[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_098[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_098, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# CADO variable 0.96 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_CADO_096 <- read.vcfR("outliers_lfmm2_CADO_096.recode.vcf")
```

```{r}
rad_out_lfmm_CADO_096.filt <- vcfR2genind(vcf_out_lfmm_CADO_096, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_CADO_096.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_CADO_096 <- scaleGen(rad_out_lfmm_CADO_096.filt, NA.method = "mean")
out_lfmm_CADO_096_pca <- dudi.pca(x_out_lfmm_CADO_096, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_CADO_096 <- round((out_lfmm_CADO_096_pca$eig / (sum(out_lfmm_CADO_096_pca$eig))) * 100, 2)

pca_dat_out_lfmm_CADO_096 <- as.data.frame(out_lfmm_CADO_096_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_CADO_096.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_CADO_096 <- pca_dat_out_lfmm_CADO_096 %>%
  mutate(Stress = ifelse(pop %in% c("CH", "RH"), "Yes", "No"))
```

```{r}
pc_scores_CADO_096 <- out_lfmm_CADO_096_pca$li
```

```{r}
permanova_result_CADO_096 <- adonis2(pc_scores_CADO_096 ~ pop, method = "euclidean")
print(permanova_result_CADO_096)
```

```{r}
permanova_result_CADO_096 <- adonis2(pc_scores_CADO_096 ~ Stress, method = "euclidean")
print(permanova_result_CADO_096)
```

```{r}
pca_data_CADO_096 <- data.frame(PC1 = pc_scores_CADO_096[,1], PC2 = pc_scores_CADO_096[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CADO_096 <- permanova_result_CADO_096$`Pr(>F)`[1]

eigenvalues_CADO_096 <- eigen(cov(pca_data_CADO_096[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_096 <- eigenvalues_CADO_096 / sum(eigenvalues_CADO_096) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_096, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_096[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_096[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_096, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_CADO_096 <- data.frame(PC1 = pc_scores_CADO_096[,1], PC2 = pc_scores_CADO_096[,2], Treatment = Stress)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Stress")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_CADO_096 <- permanova_result_CADO_096$`Pr(>F)`[1]

eigenvalues_CADO_096 <- eigen(cov(pca_data_CADO_096[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_096 <- eigenvalues_CADO_096 / sum(eigenvalues_CADO_096) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_096, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_096[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_096[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_096, digits = 2)),
           hjust = -0.1, vjust = -1)
```

# CADO variable 0.95 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_CADO_095 <- read.vcfR("outliers_lfmm2_CADO_095.recode.vcf")
```

```{r}
rad_out_lfmm_CADO_095.filt <- vcfR2genind(vcf_out_lfmm_CADO_095, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_CADO_095.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_CADO_095 <- scaleGen(rad_out_lfmm_CADO_095.filt, NA.method = "mean")
out_lfmm_CADO_095_pca <- dudi.pca(x_out_lfmm_CADO_095, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_CADO_095 <- round((out_lfmm_CADO_095_pca$eig / (sum(out_lfmm_CADO_095_pca$eig))) * 100, 2)

pca_dat_out_lfmm_CADO_095 <- as.data.frame(out_lfmm_CADO_095_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_CADO_095.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_CADO_095 <- pca_dat_out_lfmm_CADO_095 %>%
  mutate(Stress = ifelse(pop %in% c("CH", "RH"), "Yes", "No"))
```

```{r}
pc_scores_CADO_095 <- out_lfmm_CADO_095_pca$li
```

```{r}
permanova_result_CADO_095 <- adonis2(pc_scores_CADO_095 ~ pop, method = "euclidean")
print(permanova_result_CADO_095)
```

```{r}
permanova_result_CADO_095 <- adonis2(pc_scores_CADO_095 ~ Stress, method = "euclidean")
print(permanova_result_CADO_095)
```

```{r}
pca_data_CADO_095 <- data.frame(PC1 = pc_scores_CADO_095[,1], PC2 = pc_scores_CADO_095[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CADO_095 <- permanova_result_CADO_095$`Pr(>F)`[1]

eigenvalues_CADO_095 <- eigen(cov(pca_data_CADO_095[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_095 <- eigenvalues_CADO_095 / sum(eigenvalues_CADO_095) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_095, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_095[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_095[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_095, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_CADO_095 <- data.frame(PC1 = pc_scores_CADO_095[,1], PC2 = pc_scores_CADO_095[,2], Treatment = Stress)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Stress")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_CADO_095 <- permanova_result_CADO_095$`Pr(>F)`[1]

eigenvalues_CADO_095 <- eigen(cov(pca_data_CADO_095[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_095 <- eigenvalues_CADO_095 / sum(eigenvalues_CADO_095) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_095, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_095[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_095[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_095, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# CADO variable 0.94 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_CADO_094 <- read.vcfR("outliers_lfmm2_CADO_094.recode.vcf")
```

```{r}
rad_out_lfmm_CADO_094.filt <- vcfR2genind(vcf_out_lfmm_CADO_094, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_CADO_094.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_CADO_094 <- scaleGen(rad_out_lfmm_CADO_094.filt, NA.method = "mean")
out_lfmm_CADO_094_pca <- dudi.pca(x_out_lfmm_CADO_094, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_CADO_094 <- round((out_lfmm_CADO_094_pca$eig / (sum(out_lfmm_CADO_094_pca$eig))) * 100, 2)

pca_dat_out_lfmm_CADO_094 <- as.data.frame(out_lfmm_CADO_094_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_CADO_094.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_CADO_094 <- pca_dat_out_lfmm_CADO_094 %>%
  mutate(Stress = ifelse(pop %in% c("CH", "RH"), "Yes", "No"))
```

```{r}
pc_scores_CADO_094 <- out_lfmm_CADO_094_pca$li
```

```{r}
permanova_result_CADO_094 <- adonis2(pc_scores_CADO_094 ~ pop, method = "euclidean")
print(permanova_result_CADO_094)
```

```{r}
permanova_result_CADO_094 <- adonis2(pc_scores_CADO_094 ~ Stress, method = "euclidean")
print(permanova_result_CADO_094)
```

```{r}
pca_data_CADO_094 <- data.frame(PC1 = pc_scores_CADO_094[,1], PC2 = pc_scores_CADO_094[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CADO_094 <- permanova_result_CADO_094$`Pr(>F)`[1]

eigenvalues_CADO_094 <- eigen(cov(pca_data_CADO_094[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_094 <- eigenvalues_CADO_094 / sum(eigenvalues_CADO_094) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_094, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_094[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_094[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_094, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_CADO_094 <- data.frame(PC1 = pc_scores_CADO_094[,1], PC2 = pc_scores_CADO_094[,2], Treatment = Stress)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Stress")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_CADO_094 <- permanova_result_CADO_094$`Pr(>F)`[1]

eigenvalues_CADO_094 <- eigen(cov(pca_data_CADO_094[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_094 <- eigenvalues_CADO_094 / sum(eigenvalues_CADO_094) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_094, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_094[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_094[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_094, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# CADO variable 0.9 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_CADO_09 <- read.vcfR("outliers_lfmm2_CADO_09.recode.vcf")
```

```{r}
rad_out_lfmm_CADO_09.filt <- vcfR2genind(vcf_out_lfmm_CADO_09, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_CADO_09.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_CADO_09 <- scaleGen(rad_out_lfmm_CADO_09.filt, NA.method = "mean")
out_lfmm_CADO_09_pca <- dudi.pca(x_out_lfmm_CADO_09, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_CADO_09 <- round((out_lfmm_CADO_09_pca$eig / (sum(out_lfmm_CADO_09_pca$eig))) * 100, 2)

pca_dat_out_lfmm_CADO_09 <- as.data.frame(out_lfmm_CADO_09_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_CADO_09.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_CADO_09 <- pca_dat_out_lfmm_CADO_09 %>%
  mutate(Stress = ifelse(pop %in% c("CH", "RH"), "Yes", "No"))
```

```{r}
pc_scores_CADO_09 <- out_lfmm_CADO_09_pca$li
```

```{r}
permanova_result_CADO_09 <- adonis2(pc_scores_CADO_09 ~ pop, method = "euclidean")
print(permanova_result_CADO_09)
```

```{r}
permanova_result_CADO_09 <- adonis2(pc_scores_CADO_09 ~ Stress, method = "euclidean")
print(permanova_result_CADO_09)
```

```{r}
pca_data_CADO_09 <- data.frame(PC1 = pc_scores_CADO_09[,1], PC2 = pc_scores_CADO_09[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CADO_09 <- permanova_result_CADO_09$`Pr(>F)`[1]

eigenvalues_CADO_09 <- eigen(cov(pca_data_CADO_09[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_09 <- eigenvalues_CADO_09 / sum(eigenvalues_CADO_09) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_09, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_09[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_09[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_09, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_CADO_09 <- data.frame(PC1 = pc_scores_CADO_09[,1], PC2 = pc_scores_CADO_09[,2], Treatment = Stress)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Stress")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_CADO_09 <- permanova_result_CADO_09$`Pr(>F)`[1]

eigenvalues_CADO_09 <- eigen(cov(pca_data_CADO_09[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CADO_09 <- eigenvalues_CADO_09 / sum(eigenvalues_CADO_09) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CADO_09, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CADO_09[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CADO_09[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CADO_09, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# Disease variable 0.98 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_DIS_098 <- read.vcfR("outliers_lfmm2_DIS_098.recode.vcf")
```

```{r}
rad_out_lfmm_DIS_098.filt <- vcfR2genind(vcf_out_lfmm_DIS_098, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_DIS_098.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_DIS_098 <- scaleGen(rad_out_lfmm_DIS_098.filt, NA.method = "mean")
out_lfmm_DIS_098_pca <- dudi.pca(x_out_lfmm_DIS_098, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_DIS_098 <- round((out_lfmm_DIS_098_pca$eig / (sum(out_lfmm_DIS_098_pca$eig))) * 100, 2)

pca_dat_out_lfmm_DIS_098 <- as.data.frame(out_lfmm_DIS_098_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_DIS_098.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_DIS_098 <- pca_dat_out_lfmm_DIS_098 %>%
  mutate(Disease = ifelse(pop %in% c("R", "RH"), "Yes", "No"))
```

```{r}
pc_scores_DIS_098 <- out_lfmm_DIS_098_pca$li
```

```{r}
permanova_result_DIS_098 <- adonis2(pc_scores_DIS_098 ~ pop, method = "euclidean")
print(permanova_result_DIS_098)
```

```{r}
permanova_result_DIS_098 <- adonis2(pc_scores_DIS_098 ~ Disease, method = "euclidean")
print(permanova_result_DIS_098)
```

```{r}
pca_data_DIS_098 <- data.frame(PC1 = pc_scores_DIS_098[,1], PC2 = pc_scores_DIS_098[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_DIS_098 <- permanova_result_DIS_098$`Pr(>F)`[1]

eigenvalues_DIS_098 <- eigen(cov(pca_data_DIS_098[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_098 <- eigenvalues_DIS_098 / sum(eigenvalues_DIS_098) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_098, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_098[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_098[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_098, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_DIS_098 <- data.frame(PC1 = pc_scores_DIS_098[,1], PC2 = pc_scores_DIS_098[,2], Treatment = Disease)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Disease")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_DIS_098 <- permanova_result_DIS_098$`Pr(>F)`[1]

eigenvalues_DIS_098 <- eigen(cov(pca_data_DIS_098[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_098 <- eigenvalues_DIS_098 / sum(eigenvalues_DIS_098) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_098, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_098[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_098[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_098, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# Disease variable 0.97 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_DIS_097 <- read.vcfR("outliers_lfmm2_DIS_097.recode.vcf")
```

```{r}
rad_out_lfmm_DIS_097.filt <- vcfR2genind(vcf_out_lfmm_DIS_097, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_DIS_097.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_DIS_097 <- scaleGen(rad_out_lfmm_DIS_097.filt, NA.method = "mean")
out_lfmm_DIS_097_pca <- dudi.pca(x_out_lfmm_DIS_097, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_DIS_097 <- round((out_lfmm_DIS_097_pca$eig / (sum(out_lfmm_DIS_097_pca$eig))) * 100, 2)

pca_dat_out_lfmm_DIS_097 <- as.data.frame(out_lfmm_DIS_097_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_DIS_097.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_DIS_097 <- pca_dat_out_lfmm_DIS_097 %>%
  mutate(Disease = ifelse(pop %in% c("R", "RH"), "Yes", "No"))
```

```{r}
pc_scores_DIS_097 <- out_lfmm_DIS_097_pca$li
```

```{r}
permanova_result_DIS_097 <- adonis2(pc_scores_DIS_097 ~ pop, method = "euclidean")
print(permanova_result_DIS_097)
```

```{r}
permanova_result_DIS_097 <- adonis2(pc_scores_DIS_097 ~ Disease, method = "euclidean")
print(permanova_result_DIS_097)
```

```{r}
pca_data_DIS_097 <- data.frame(PC1 = pc_scores_DIS_097[,1], PC2 = pc_scores_DIS_097[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_DIS_097 <- permanova_result_DIS_097$`Pr(>F)`[1]

eigenvalues_DIS_097 <- eigen(cov(pca_data_DIS_097[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_097 <- eigenvalues_DIS_097 / sum(eigenvalues_DIS_097) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_097, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_097[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_097[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_097, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_DIS_097 <- data.frame(PC1 = pc_scores_DIS_097[,1], PC2 = pc_scores_DIS_097[,2], Treatment = Disease)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Disease")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_DIS_097 <- permanova_result_DIS_097$`Pr(>F)`[1]

eigenvalues_DIS_097 <- eigen(cov(pca_data_DIS_097[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_097 <- eigenvalues_DIS_097 / sum(eigenvalues_DIS_097) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_097, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_097[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_097[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_097, digits = 2)),
           hjust = -0.1, vjust = -1)
```

# Disease variable 0.96 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_DIS_096 <- read.vcfR("outliers_lfmm2_DIS_096.recode.vcf")
```

```{r}
rad_out_lfmm_DIS_096.filt <- vcfR2genind(vcf_out_lfmm_DIS_096, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_DIS_096.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_DIS_096 <- scaleGen(rad_out_lfmm_DIS_096.filt, NA.method = "mean")
out_lfmm_DIS_096_pca <- dudi.pca(x_out_lfmm_DIS_096, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_DIS_096 <- round((out_lfmm_DIS_096_pca$eig / (sum(out_lfmm_DIS_096_pca$eig))) * 100, 2)

pca_dat_out_lfmm_DIS_096 <- as.data.frame(out_lfmm_DIS_096_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_DIS_096.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_DIS_096 <- pca_dat_out_lfmm_DIS_096 %>%
  mutate(Disease = ifelse(pop %in% c("R", "RH"), "Yes", "No"))
```

```{r}
pc_scores_DIS_096 <- out_lfmm_DIS_096_pca$li
```

```{r}
permanova_result_DIS_096 <- adonis2(pc_scores_DIS_096 ~ pop, method = "euclidean")
print(permanova_result_DIS_096)
```

```{r}
permanova_result_DIS_096 <- adonis2(pc_scores_DIS_096 ~ Disease, method = "euclidean")
print(permanova_result_DIS_096)
```

```{r}
pca_data_DIS_096 <- data.frame(PC1 = pc_scores_DIS_096[,1], PC2 = pc_scores_DIS_096[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_DIS_096 <- permanova_result_DIS_096$`Pr(>F)`[1]

eigenvalues_DIS_096 <- eigen(cov(pca_data_DIS_096[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_096 <- eigenvalues_DIS_096 / sum(eigenvalues_DIS_096) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_096, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_096[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_096[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_096, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_DIS_096 <- data.frame(PC1 = pc_scores_DIS_096[,1], PC2 = pc_scores_DIS_096[,2], Treatment = Disease)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Disease")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_DIS_096 <- permanova_result_DIS_096$`Pr(>F)`[1]

eigenvalues_DIS_096 <- eigen(cov(pca_data_DIS_096[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_096 <- eigenvalues_DIS_096 / sum(eigenvalues_DIS_096) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_096, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_096[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_096[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_096, digits = 2)),
           hjust = -0.1, vjust = -1)
```

# Disease variable 0.93 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_DIS_093 <- read.vcfR("outliers_lfmm2_DIS_093.recode.vcf")
```

```{r}
rad_out_lfmm_DIS_093.filt <- vcfR2genind(vcf_out_lfmm_DIS_093, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_DIS_093.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_DIS_093 <- scaleGen(rad_out_lfmm_DIS_093.filt, NA.method = "mean")
out_lfmm_DIS_093_pca <- dudi.pca(x_out_lfmm_DIS_093, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_DIS_093 <- round((out_lfmm_DIS_093_pca$eig / (sum(out_lfmm_DIS_093_pca$eig))) * 100, 2)

pca_dat_out_lfmm_DIS_093 <- as.data.frame(out_lfmm_DIS_093_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_DIS_093.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_DIS_093 <- pca_dat_out_lfmm_DIS_093 %>%
  mutate(Disease = ifelse(pop %in% c("R", "RH"), "Yes", "No"))
```

```{r}
pc_scores_DIS_093 <- out_lfmm_DIS_093_pca$li
```

```{r}
permanova_result_DIS_093 <- adonis2(pc_scores_DIS_093 ~ pop, method = "euclidean")
print(permanova_result_DIS_093)
```

```{r}
permanova_result_DIS_093 <- adonis2(pc_scores_DIS_093 ~ Disease, method = "euclidean")
print(permanova_result_DIS_093)
```

```{r}
pca_data_DIS_093 <- data.frame(PC1 = pc_scores_DIS_093[,1], PC2 = pc_scores_DIS_093[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_DIS_093 <- permanova_result_DIS_093$`Pr(>F)`[1]

eigenvalues_DIS_093 <- eigen(cov(pca_data_DIS_093[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_093 <- eigenvalues_DIS_093 / sum(eigenvalues_DIS_093) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_093, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_093[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_093[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_093, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_DIS_093 <- data.frame(PC1 = pc_scores_DIS_093[,1], PC2 = pc_scores_DIS_093[,2], Treatment = Disease)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Disease")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_DIS_093 <- permanova_result_DIS_093$`Pr(>F)`[1]

eigenvalues_DIS_093 <- eigen(cov(pca_data_DIS_093[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_093 <- eigenvalues_DIS_093 / sum(eigenvalues_DIS_093) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_093, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_093[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_093[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_093, digits = 2)),
           hjust = -0.1, vjust = -1)
```

# Disease variable 0.92 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_DIS_092 <- read.vcfR("outliers_lfmm2_DIS_092.recode.vcf")
```

```{r}
rad_out_lfmm_DIS_092.filt <- vcfR2genind(vcf_out_lfmm_DIS_092, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_DIS_092.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_DIS_092 <- scaleGen(rad_out_lfmm_DIS_092.filt, NA.method = "mean")
out_lfmm_DIS_092_pca <- dudi.pca(x_out_lfmm_DIS_092, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_DIS_092 <- round((out_lfmm_DIS_092_pca$eig / (sum(out_lfmm_DIS_092_pca$eig))) * 100, 2)

pca_dat_out_lfmm_DIS_092 <- as.data.frame(out_lfmm_DIS_092_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_DIS_092.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_DIS_092 <- pca_dat_out_lfmm_DIS_092 %>%
  mutate(Disease = ifelse(pop %in% c("R", "RH"), "Yes", "No"))
```

```{r}
pc_scores_DIS_092 <- out_lfmm_DIS_092_pca$li
```

```{r}
permanova_result_DIS_092 <- adonis2(pc_scores_DIS_092 ~ pop, method = "euclidean")
print(permanova_result_DIS_092)
```

```{r}
permanova_result_DIS_092 <- adonis2(pc_scores_DIS_092 ~ Disease, method = "euclidean")
print(permanova_result_DIS_092)
```

```{r}
pca_data_DIS_092 <- data.frame(PC1 = pc_scores_DIS_092[,1], PC2 = pc_scores_DIS_092[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_DIS_092 <- permanova_result_DIS_092$`Pr(>F)`[1]

eigenvalues_DIS_092 <- eigen(cov(pca_data_DIS_092[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_092 <- eigenvalues_DIS_092 / sum(eigenvalues_DIS_092) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_092, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_092[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_092[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_092, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_DIS_092 <- data.frame(PC1 = pc_scores_DIS_092[,1], PC2 = pc_scores_DIS_092[,2], Treatment = Disease)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Disease")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_DIS_092 <- permanova_result_DIS_092$`Pr(>F)`[1]

eigenvalues_DIS_092 <- eigen(cov(pca_data_DIS_092[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_092 <- eigenvalues_DIS_092 / sum(eigenvalues_DIS_092) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_092, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_092[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_092[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_092, digits = 2)),
           hjust = -0.1, vjust = -1)
```

# Disease variable 0.9 GIF

```{r}
# Read in VCF file
vcf_out_lfmm_DIS_09 <- read.vcfR("outliers_lfmm2_DIS_09.recode.vcf")
```

```{r}
rad_out_lfmm_DIS_09.filt <- vcfR2genind(vcf_out_lfmm_DIS_09, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_DIS_09.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_DIS_09 <- scaleGen(rad_out_lfmm_DIS_09.filt, NA.method = "mean")
out_lfmm_DIS_09_pca <- dudi.pca(x_out_lfmm_DIS_09, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_DIS_09 <- round((out_lfmm_DIS_09_pca$eig / (sum(out_lfmm_DIS_09_pca$eig))) * 100, 2)

pca_dat_out_lfmm_DIS_09 <- as.data.frame(out_lfmm_DIS_09_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_DIS_09.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_DIS_09 <- pca_dat_out_lfmm_DIS_09 %>%
  mutate(Disease = ifelse(pop %in% c("R", "RH"), "Yes", "No"))
```

```{r}
pc_scores_DIS_09 <- out_lfmm_DIS_09_pca$li
```

```{r}
permanova_result_DIS_09 <- adonis2(pc_scores_DIS_09 ~ pop, method = "euclidean")
print(permanova_result_DIS_09)
```

```{r}
permanova_result_DIS_09 <- adonis2(pc_scores_DIS_09 ~ Disease, method = "euclidean")
print(permanova_result_DIS_09)
```

```{r}
pca_data_DIS_09 <- data.frame(PC1 = pc_scores_DIS_09[,1], PC2 = pc_scores_DIS_09[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_DIS_09 <- permanova_result_DIS_09$`Pr(>F)`[1]

eigenvalues_DIS_09 <- eigen(cov(pca_data_DIS_09[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_09 <- eigenvalues_DIS_09 / sum(eigenvalues_DIS_09) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_09, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_09[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_09[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_09, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_DIS_09 <- data.frame(PC1 = pc_scores_DIS_09[,1], PC2 = pc_scores_DIS_09[,2], Treatment = Disease)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Disease")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#E69F00")

# Extract p-value from PERMANOVA result
p_value_DIS_09 <- permanova_result_DIS_09$`Pr(>F)`[1]

eigenvalues_DIS_09 <- eigen(cov(pca_data_DIS_09[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_DIS_09 <- eigenvalues_DIS_09 / sum(eigenvalues_DIS_09) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_DIS_09, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_DIS_09[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_DIS_09[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_DIS_09, digits = 2)),
           hjust = -0.1, vjust = -1)
```

# Combined treatment - Binary

```{r}
Combined <- c(rep("No", 20),rep("No", 20),rep("No", 20),rep("Yes", 20))
```

```{r}
# Read in VCF file
vcf_out_lfmm_CB <- read.vcfR("outliers_lfmm2_CB.recode.vcf")
```

```{r}
rad_out_lfmm_CB.filt <- vcfR2genind(vcf_out_lfmm_CB, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_CB.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_CB <- scaleGen(rad_out_lfmm_CB.filt, NA.method = "mean")
out_lfmm_CB_pca <- dudi.pca(x_out_lfmm_CB, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_CB <- round((out_lfmm_CB_pca$eig / (sum(out_lfmm_CB_pca$eig))) * 100, 2)

pca_dat_out_lfmm_CB <- as.data.frame(out_lfmm_CB_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_CB.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_CB <- pca_dat_out_lfmm_CB %>%
  mutate(Combined = ifelse(pop %in% c("RH"), "Yes", "No"))
```

```{r}
pc_scores_CB <- out_lfmm_CB_pca$li
```

```{r}
permanova_result_CB <- adonis2(pc_scores_CB ~ pop, method = "euclidean")
print(permanova_result_CB)
```

```{r}
permanova_result_CB <- adonis2(pc_scores_CB ~ Combined, method = "euclidean")
print(permanova_result_CB)
```

```{r}
pca_data_CB <- data.frame(PC1 = pc_scores_CB[,1], PC2 = pc_scores_CB[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CB <- permanova_result_CB$`Pr(>F)`[1]

eigenvalues_CB <- eigen(cov(pca_data_CB[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CB <- eigenvalues_CB / sum(eigenvalues_CB) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CB, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CB[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CB[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CB, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_CB <- data.frame(PC1 = pc_scores_CB[,1], PC2 = pc_scores_CB[,2], Treatment = Combined)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Combined")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_CB <- permanova_result_CB$`Pr(>F)`[1]

eigenvalues_CB <- eigen(cov(pca_data_CB[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_CB <- eigenvalues_CB / sum(eigenvalues_CB) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_CB, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_CB[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_CB[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_CB, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# Combined treatment - Additive

```{r}
# Read in VCF file
vcf_out_lfmm_C_ADD <- read.vcfR("outliers_lfmm2_C_ADD.recode.vcf")
```

```{r}
rad_out_lfmm_C_ADD.filt <- vcfR2genind(vcf_out_lfmm_C_ADD, strata = strata_ROD, pop = c(rep("C", 20),rep("CH", 20),rep("R", 20),rep("RH", 20)))

rad_out_lfmm_C_ADD.filt
```

```{r}
# Plot a PCA for the all outlier loci
x_out_lfmm_C_ADD <- scaleGen(rad_out_lfmm_C_ADD.filt, NA.method = "mean")
out_lfmm_C_ADD_pca <- dudi.pca(x_out_lfmm_C_ADD, center = FALSE, scale = FALSE, scannf = FALSE, nf = 4)
eig_percent_out_lfmm_C_ADD <- round((out_lfmm_C_ADD_pca$eig / (sum(out_lfmm_C_ADD_pca$eig))) * 100, 2)

pca_dat_out_lfmm_C_ADD <- as.data.frame(out_lfmm_C_ADD_pca$li) %>%
                    rownames_to_column(var = "ind") %>%
                    cbind(pop = pop(rad_out_lfmm_C_ADD.filt)) %>%
                    mutate(pop = factor(pop, levels = c("C", "CH","R", "RH")))

pca_dat_out_lfmm_C_ADD <- pca_dat_out_lfmm_C_ADD %>%
  mutate(Combined = ifelse(pop %in% c("RH"), "Yes", "No"))
```

```{r}
pc_scores_C_ADD <- out_lfmm_C_ADD_pca$li
```

```{r}
permanova_result_C_ADD <- adonis2(pc_scores_C_ADD ~ pop, method = "euclidean")
print(permanova_result_C_ADD)
```

```{r}
permanova_result_C_ADD <- adonis2(pc_scores_C_ADD ~ Combined, method = "euclidean")
print(permanova_result_C_ADD)
```

```{r}
pca_data_C_ADD <- data.frame(PC1 = pc_scores_C_ADD[,1], PC2 = pc_scores_C_ADD[,2], Treatment = pop)

# Define new treatment names
treatment_names <- c("C" = "CONCON",
                         "CH" = "STRCON",
                         "R" = "CONROD",
                         "RH" = "STRROD")

# Define custom colors
custom_colors <- c("C" = "#0072B2", "CH" = "#56B4E9", "R" = "#E69F00", "RH" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_C_ADD <- permanova_result_C_ADD$`Pr(>F)`[1]

eigenvalues_C_ADD <- eigen(cov(pca_data_C_ADD[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_C_ADD <- eigenvalues_C_ADD / sum(eigenvalues_C_ADD) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_C_ADD, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_C_ADD[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_C_ADD[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_C_ADD, digits = 2)),
           hjust = -0.1, vjust = -1)
```

```{r}
pca_data_C_ADD <- data.frame(PC1 = pc_scores_C_ADD[,1], PC2 = pc_scores_C_ADD[,2], Treatment = Combined)

# Define new treatment names
treatment_names <- c("No" = "Control",
                         "Yes" = "Combined")

# Define custom colors
custom_colors <- c("No" = "#0072B2","Yes" = "#F0E442")

# Extract p-value from PERMANOVA result
p_value_C_ADD <- permanova_result_C_ADD$`Pr(>F)`[1]

eigenvalues_C_ADD <- eigen(cov(pca_data_C_ADD[, c("PC1", "PC2")]))$values

# Calculate proportion of variance explained
pve_C_ADD <- eigenvalues_C_ADD / sum(eigenvalues_C_ADD) * 100

# Create the plot with proportion of variance on axes
ggplot(pca_data_C_ADD, aes(x = PC1, y = PC2, color = Treatment)) +
  geom_point() +
  stat_ellipse() +
  theme_minimal() +
  scale_color_manual(values = custom_colors, labels = treatment_names) +
  xlab(paste0("PC1 (", round(pve_C_ADD[1], 2), "%)")) +
  ylab(paste0("PC2 (", round(pve_C_ADD[2], 2), "%)")) +
  annotate("text", x = -Inf, y = -Inf, 
           label = paste("PERMANOVA\n p =", format(p_value_C_ADD, digits = 2)),
           hjust = -0.1, vjust = -1)
```


# Looking for overlapping outliers

```{bash}
# CADO Outliers
sort outliers_lfmm2_CADO_098.txt > outliers_lfmm2_CADO_098_sorted.txt
sort outliers_lfmm2_CADO_096.txt > outliers_lfmm2_CADO_096_sorted.txt
sort outliers_lfmm2_CADO_095.txt > outliers_lfmm2_CADO_095_sorted.txt
sort outliers_lfmm2_CADO_094.txt > outliers_lfmm2_CADO_094_sorted.txt
sort outliers_lfmm2_CADO_09.txt > outliers_lfmm2_CADO_09_sorted.txt

# Disease Outliers
sort outliers_lfmm2_DIS_098.txt > outliers_lfmm2_DIS_098_sorted.txt
sort outliers_lfmm2_DIS_097.txt > outliers_lfmm2_DIS_097_sorted.txt
sort outliers_lfmm2_DIS_096.txt > outliers_lfmm2_DIS_096_sorted.txt
sort outliers_lfmm2_DIS_093.txt > outliers_lfmm2_DIS_093_sorted.txt
sort outliers_lfmm2_DIS_092.txt > outliers_lfmm2_DIS_092_sorted.txt
sort outliers_lfmm2_DIS_09.txt > outliers_lfmm2_DIS_09_sorted.txt

# Combined treatment
sort outliers_lfmm2_CB.txt > outliers_lfmm2_CB_sorted.txt
sort outliers_lfmm2_C_ADD.txt > outliers_lfmm2_C_ADD_sorted.txt
```

```{bash}
comm -12 outliers_lfmm2_CADO_098_sorted.txt outliers_lfmm2_CADO_096_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_098_sorted.txt outliers_lfmm2_CADO_095_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_098_sorted.txt outliers_lfmm2_CADO_094_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_098_sorted.txt outliers_lfmm2_CADO_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_096_sorted.txt outliers_lfmm2_CADO_095_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_096_sorted.txt outliers_lfmm2_CADO_094_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_096_sorted.txt outliers_lfmm2_CADO_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_095_sorted.txt outliers_lfmm2_CADO_094_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_095_sorted.txt outliers_lfmm2_CADO_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_094_sorted.txt outliers_lfmm2_CADO_09_sorted.txt | wc -l
```

```{bash}
comm -12 outliers_lfmm2_DIS_098_sorted.txt outliers_lfmm2_DIS_097_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_098_sorted.txt outliers_lfmm2_DIS_096_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_098_sorted.txt outliers_lfmm2_DIS_093_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_098_sorted.txt outliers_lfmm2_DIS_092_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_098_sorted.txt outliers_lfmm2_DIS_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_097_sorted.txt outliers_lfmm2_DIS_096_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_097_sorted.txt outliers_lfmm2_DIS_093_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_097_sorted.txt outliers_lfmm2_DIS_092_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_097_sorted.txt outliers_lfmm2_DIS_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_096_sorted.txt outliers_lfmm2_DIS_093_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_096_sorted.txt outliers_lfmm2_DIS_092_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_096_sorted.txt outliers_lfmm2_DIS_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_093_sorted.txt outliers_lfmm2_DIS_092_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_093_sorted.txt outliers_lfmm2_DIS_09_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_092_sorted.txt outliers_lfmm2_DIS_09_sorted.txt | wc -l
```

```{bash}
comm -12 outliers_lfmm2_CB_sorted.txt outliers_lfmm2_C_ADD_sorted.txt | wc -l
```

```{bash}
comm -12 outliers_lfmm2_CADO_098_sorted.txt outliers_lfmm2_DIS_098_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_096_sorted.txt outliers_lfmm2_DIS_096_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_095_sorted.txt outliers_lfmm2_DIS_093_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_094_sorted.txt outliers_lfmm2_DIS_092_sorted.txt | wc -l
comm -12 outliers_lfmm2_CADO_09_sorted.txt outliers_lfmm2_DIS_09_sorted.txt | wc -l

# Comparing the largest set of Stress and Disease outliers with the largest combined outliers
comm -12 outliers_lfmm2_CADO_09_sorted.txt outliers_lfmm2_CB_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_09_sorted.txt outliers_lfmm2_CB_sorted.txt | wc -l

# Comparing the next largest set of Stress and Disease outliers with the combined outliers
comm -12 outliers_lfmm2_CADO_094_sorted.txt outliers_lfmm2_CB_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_092_sorted.txt outliers_lfmm2_CB_sorted.txt | wc -l

comm -12 outliers_lfmm2_CADO_09_sorted.txt outliers_lfmm2_C_ADD_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_09_sorted.txt outliers_lfmm2_C_ADD_sorted.txt | wc -l

comm -12 outliers_lfmm2_CADO_094_sorted.txt outliers_lfmm2_C_ADD_sorted.txt | wc -l
comm -12 outliers_lfmm2_DIS_092_sorted.txt outliers_lfmm2_C_ADD_sorted.txt | wc -l
```


# Saving outliers to a BED file

We decided to move forward with the outlier SNPs associated with the combined (binary) treatment, the 0.98 GIF-modified Stress treatment, and the 0.98 GIF-modified Disease treatment.

The txt files including chromosome and bp position for each of these were made in chunks on line 481 and 489:

`outliers_lfmm2_CB.loci.txt`, `outliers_lfmm2_CADO_098.loci.txt`, and `outliers_lfmm2_DIS_098.loci.txt`.

We'll combine all three LFMM2 outliers into a new combined txt file with all lfmm2 outliers called 'all_lfmm2_outliers':

```{bash}
cat outliers_lfmm2_CB.loci.txt outliers_lfmm2_CADO_098.loci.txt outliers_lfmm2_DIS_098.loci.txt > all_lfmm2_outliers
```

Now, convert it to a bed file:

```{bash}
awk '{print $1 "\t" $2-1 "\t" $2}' all_lfmm2_outliers | bedtools sort -i - > outliers_lfmm2.bed
```








